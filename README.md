# 数据结构

## 1、如何高效学习数据结构与算法

### 一、数据结构的存储方式

**数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）**。

这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？

我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。**因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。**

比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。

了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。

综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，**二者的优缺点如下**：

**数组**由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，**内存空间必须一次性分配够**，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以**不能随机访问**；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 二、数据结构的基本操作

对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。

**数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改**。话说这不就是数据结构的使命么？

如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。

线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：

数组遍历框架，典型的线性迭代结构：

```java
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        // 迭代访问 arr[i]
    }
}
```

链表遍历框架，兼具迭代和递归结构：

```java
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}

void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
        // 迭代访问 p.val
    }
}

void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next)
}
```

二叉树遍历框架，典型的非线性递归遍历结构：

```java
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    traverse(root.left)
    traverse(root.right)
}
```

你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？

二叉树框架可以扩展为 N 叉树的遍历框架：

```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}

void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child)
}
```

N 叉树的遍历又可以扩展为图的遍历，因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 visited 做标记就行了，这里就不写代码了。

**所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例**。

### 三、算法刷题指南

首先要明确的是，**数据结构是工具，算法是通过合适的工具解决特定问题的方法**。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。

那么该如何在 LeetCode 刷题呢？之前的文章[算法学习之路](算法学习之路.md)写过一些，什么按标签刷，坚持下去云云。现在距那篇文章已经过去将近一年了，我不说那些不痛不痒的话，直接说具体的建议：

**先刷二叉树，先刷二叉树，先刷二叉树**！

为什么要先刷二叉树呢，**因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题**。

刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。**不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了**。

```java
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。

LeetCode 124 题，难度 Hard，让你求二叉树中最大路径和，主要代码如下：

```cpp
int ans = INT_MIN;
int oneSideMax(TreeNode* root) {
    if (root == nullptr) return 0;
    int left = max(0, oneSideMax(root->left));
    int right = max(0, oneSideMax(root->right));
    ans = max(ans, left + right + root->val);
    return max(left, right) + root->val;
}
```

你看，这就是个后序遍历嘛。

LeetCode 105 题，难度 Medium，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下：

```java
TreeNode buildTree(int[] preorder, int preStart, int preEnd, 
    int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {

    if(preStart > preEnd || inStart > inEnd) return null;

    TreeNode root = new TreeNode(preorder[preStart]);
    int inRoot = inMap.get(root.val);
    int numsLeft = inRoot - inStart;

    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, 
                          inorder, inStart, inRoot - 1, inMap);
    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, 
                          inorder, inRoot + 1, inEnd, inMap);
    return root;
}
```

不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。

LeetCode 99 题，难度 Hard，恢复一棵 BST，主要代码如下：

```cpp
void traverse(TreeNode* node) {
    if (!node) return;
    traverse(node->left);
    if (node->val < prev->val) {
        s = (s == NULL) ? prev : s;
        t = node;
    }
    prev = node;
    traverse(node->right);
}
```

这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。

你看，Hard 难度的题目不过如此，而且还这么有规律可循，只要把框架写出来，然后往相应的位置加东西就行了，这不就是思路吗。

对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，**你就会发现只要涉及递归的问题，都是树的问题**。

再举例吧，说几道我们之前文章写过的问题。

[动态规划详解](../动态规划系列/动态规划详解进阶.md)说过凑零钱问题，暴力解法就是遍历一棵 N 叉树：

![](D:/%E9%A1%B9%E7%9B%AE/JavaGuide/fucking-algorithm/pictures/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6/5.jpg)

```python
def coinChange(coins: List[int], amount: int):

    def dp(n):
        if n == 0: return 0
        if n < 0: return -1

        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)
        return res if res != float('INF') else -1
    
    return dp(amount)
```

这么多代码看不懂咋办？直接提取出框架，就能看出核心思路了：

```python
# 不过是一个 N 叉树的遍历问题而已
def dp(n):
    for coin in coins:
        dp(n - coin)
```

其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。

再看看回溯算法，前文[回溯算法详解](回溯算法详解修订版.md)干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。

比如 N 皇后问题吧，主要代码如下：

```java
void backtrack(int[] nums, LinkedList<Integer> track) {
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }
    
    for (int i = 0; i < nums.length; i++) {
        if (track.contains(nums[i]))
            continue;
        track.add(nums[i]);
        // 进入下一层决策树
        backtrack(nums, track);
        track.removeLast();
    }

/* 提取出 N 叉树遍历框架 */
void backtrack(int[] nums, LinkedList<Integer> track) {
    for (int i = 0; i < nums.length; i++) {
        backtrack(nums, track);
}
```

N 叉树的遍历框架，找出来了把～你说，树这种结构重不重要？

**综上，对于畏惧算法的朋友来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题**。

纠结细节问题，就比如纠结 i 到底应该加到 n 还是加到 n - 1，这个数组的大小到底应该开 n 还是 n + 1 ？

从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。

当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。

### 四、小结：

- **数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）**。

- **数组**初始化时，就必须分配好内存空间，当容量不够时，就需要扩容，涉及到元素的复制，另外数据时连续存储的结构，插入和删除中间元素时，就需要移动后面的元素；他的好处就是可以根据下标，直接随机访问。

- **链表**无法根据一个索引算出对应元素的地址，所以不能随机访问。

- **数据结构的基本操作**也就是增删改查+遍历访问。

- 各种数据结构的遍历访问无非两种形式（线性的和非线性的）：线性就是 **for/while 迭代**为代表，非线性就是**递归**为代表。

- 算法刷题：**先刷二叉树，先刷二叉树，先刷二叉树**！

- 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。

  刷算法题建议从「树」分类开始刷，刷之前，先了解一下基本概念，刷题时结合框架思维，把这几十道题刷完。关键还是找到规律，公式、往里面套就行，能做到举一反三，将脑力劳动变为体力劳动。

## 2、关于树的基本概念

### 1 前言

​		**因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题**

  **树**是数据结构中的重中之重，尤其以各类二叉树为学习的难点。本文将详细讲述树的基本概念以及树构造和遍历，为后续深入学习做好基础。

### 2 概念

#### 2.1 节点

  **节点：**是数据结构中的基础，是构成复杂数据结构的基本组成单位。

#### 2.2 树节点

  本系列文章中提及的节点专指树的节点。例如：节点A表示为：
![树节点A](https://images.xiaozhuanlan.com/photo/2019/1a74a03950f3cc44e04c71f3613f7ff4.png)

### 3 树

#### 3.1 定义

  **树（Tree）**是n（n>=0)个节点的有限集。n=0时称为**空树**。在任意一颗非空树中：
  （1）有且仅有一个特定的称为根（Root）的节点；
  （2）当n>1时，其余节点可分为m(m>0)个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。
此外，树的定义还需要强调以下两点：
  （3）n>0时根节点是唯一的，不可能存在多个根节点，数据结构中的树只能有一个根节点。
  （4）m>0时，子树的个数没有限制，但它们一定是互不相交的。

  例如：图3.1中所示的树为一棵有10个节点的一般树。
![图3.1 一般树](https://images.xiaozhuanlan.com/photo/2019/581613b4bfafc7133283d12413aeb460.png)

- 由树的定义可以看出，**树的定义使用了递归的方式**。递归在树的学习过程中起着重要作用。
- 树是有且仅有一个根节点的，当树节点n == 0 时，成为空树。
- 树的每个孩子又是一棵树，所以树使用了递归的方式，**递归在树结构中非常非常重要**。

#### 3.2 节点的度

  **定义：**节点拥有的子树数目称为节点的**度**。例如：图3.2中标注了图3.1所示树的各个节点的度。
![图3.2 节点的度](https://images.xiaozhuanlan.com/photo/2019/1bde1e8122201a60f718d4477d900083.png)

换句话说就是这个节点开了几个岔，度就是几。

#### 3.3 节点关系

  节点子树的根节点为该节点的**孩子节点**。相应该节点称为孩子节点的**双亲节点**。图3.2中，A为B的双亲节点，B为A的孩子节点。
  同一个双亲节点的孩子节点之间互称**兄弟节点**。图3.2中，B与C互为兄弟节点，GHI互为兄弟节点，EF互为兄弟节点。

#### 3.4 节点层次

  从根节点开始，根节点为第一层，根的孩子为第二层，以此类推。例如：图3.4表示了图3.1所示树的层次关系
![图3.4 节点层次](https://images.xiaozhuanlan.com/photo/2019/9e29af97f8222291339d9fba19203beb.png)



#### 3.5 树的深度

  树中节点的最大层次数称为树的深度或高度。例如：图3.1所示树的深度为4。

### 4 二叉树

#### 4.1 定义

  **二叉树**是n(n>=0)个节点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树组成。

​		顾明思义：就是每个节点至多有两个度（两个分叉）的树。

图4.1展示了一棵一般二叉树：
![图4.1 一般二叉树](https://images.xiaozhuanlan.com/photo/2019/d058744643e16929f4c0a13112e4792b.png)

图4.1 一般二叉树



#### 4.2 二叉树特点

  由二叉树的定义，以及图中所示的二叉树的分析可以得出二叉树具有以下几个特点：
  （1）每个节点最多有两颗子树，所以二叉树中不存在度大于2的节点。
  （2）左子树和右子树是有顺序的，次序不能任意颠倒。
  （3）即使树中某节点只有一棵子树，也要区分它是左子树还是右子树。

#### 4.3 二叉树性质

  （1）在二叉树的第i层上最多有
$$
2^{i-1}
$$
 				个节点 。（i>=1）1  2  4   8
  （2）二叉树中如果深度为k,那么最多有
$$
2^k-1
$$
​				个节点。(k>=1） 1  3  7  15
  （3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。

因为二叉树所有结点滴个数都不大于2，所以结点总数n=n0+n1+n2 (1)又因为度为1和度为2的结点分别有1个子树和2个子树，所以，二叉树中子树结点就有n(子）=n1+2n2二叉树中只有根节点不是子树结点，所以二叉树结点总数n=n(子）+1 即 n=n1+2n2+1 (2)结合（1）式和（2）式就得n0=n2+1

  （4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。
  （5）若对含 n 个节点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的节点有如下特性：
    （5）- 1，若 i=1，则该节点是二叉树的根，无双亲, 否则，编号为 [i/2] 的节点为其双亲节点;
    （5）- 2，若 2i>n，则该节点无左孩子， 否则，编号为 2i 的节点为其左孩子节点；
    （5）- 3，若 2i+1>n，则该节点无右孩子节点， 否则，编号为2i+1 的节点为其右孩子节点。

#### 4.4 斜树

  **斜树**：所有的节点都只有左子树的二叉树叫左斜树。所有节点都是只有右子树的二叉树叫右斜树，这两者统称为斜树。
![图4.4.1 左斜树](https://images.xiaozhuanlan.com/photo/2019/58a5c9c2f42d471dc56f87862555eafe.png)

图4.4.1 左斜树


![图4.4.2 右斜树](https://images.xiaozhuanlan.com/photo/2019/2fdcece03146aaa2837a2037155924f3.png)



#### 4.5 满二叉树

   **满二叉树**：在一棵二叉树中。如果**所有分支节点都存在左子树和右子树**，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。
满二叉树的特点有：
  （1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。
  （2）非叶子节点的度一定是2。
  （3）在同样深度的二叉树中，满二叉树的节点个数最多，叶子节点数最多。

![图4.5 满二叉树](https://images.xiaozhuanlan.com/photo/2019/887a6e1ca925b5c7f5efee3e65c7bb1a.png)

图4.5 满二叉树



#### 4.6 完全二叉树

  **完全二叉树**：对一颗具有n个节点的二叉树按层编号，如果编号为i(1<=i<=n)的节点与同样深度的满二叉树中编号为i的节点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 图4.6为一棵完全二叉树.

​		就是满二叉树，砍掉右侧叶子。所以说满二叉树也是完全二叉树。

![图4.6 完全二叉树](https://images.xiaozhuanlan.com/photo/2019/8137c2e57ad6830c16e90e18d7b9cf8a.png)

图4.6 完全二叉树



**完全二叉树特点**：
  （1）叶子节点只能出现在最下层和次下层。
  （2）最下层的叶子节点集中在树的左部。
  （3）倒数第二层若存在叶子节点，一定在右部连续位置。
  （4）如果节点度为1，则该节点只有左孩子，即没有右子树。
  （5）同样节点数目的二叉树，完全二叉树深度最小。

  **注**：满二叉树一定是完全二叉树，但反过来不一定成立。

#### 4.7 二叉树的存储结构

**（1）顺序存储**
  二叉树的顺序存储结构就是使用一维数组存储二叉树中的节点，并且节点的存储位置，就是数组的下标索引。
![图4.6 完全二叉树](https://images.xiaozhuanlan.com/photo/2019/af84c9443d61b8e0dafc314b9a5f42bf.png)

图4.6 完全二叉树



  例如：图4.6所示的一棵完全二叉树采用顺序存储方式，如图4.7.1表示：
![图4.7.1 顺序存储](https://images.xiaozhuanlan.com/photo/2019/8b38bdf45ed8489d609fb728300f66d1.png)

图4.7.1 顺序存储



  由图4.7.1可以看出，当二叉树为完全二叉树时，节点数刚好填满数组。那么当二叉树不为完全二叉树时，采用顺序存储形式如何呢？例如：对于图4.7.2描述的二叉树：
![图4.7.2](https://images.xiaozhuanlan.com/photo/2019/151e874fe831a37366797360b233dec3.png)

  其中，未填充节点表示节点不存在。那么图4.7.2所示的二叉树的顺序存储结构如图4.7.3所示：
![图4.7.3](https://images.xiaozhuanlan.com/photo/2019/5a74833c27012c97b6e36eaa5ebdff81.png)

  其中，∧表示数组中此位置没有存储节点。此时可以发现，顺序存储结构中已经出现了空间浪费的情况。
  那么对于图4.4.2所示的右斜树极端情况对应的顺序存储结构如图4.7.4所示：
![图4.7.4](https://images.xiaozhuanlan.com/photo/2019/f24dafff5398fc7e609e1ead630204d1.png)

  由图4.7.4可以看出，对于这种右斜树极端情况，采用顺序存储的方式是十分浪费空间的。因此，顺序存储一般适用于完全二叉树。

**（2）二叉链表**
  既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个节点最多有两个孩子。因此，可以将节点数据结构定义为一个数据和两个指针域。表示方式如图4.7.5所示：
![图4.7.5](https://images.xiaozhuanlan.com/photo/2019/26e46767f5931877752587cdb0fdb159.png)



定义节点代码：

```
typedef struct BiTNode{
    TElemType data;//数据
    struct BiTNode *lchild, *rchild;//左右孩子指针
} BiTNode, *BiTree;
```

  则图4.6所示的完全二叉树可以采用图4.7.6表示。
![图4.7.6](https://images.xiaozhuanlan.com/photo/2019/bb166099813d3cf7040675ae755ac863.png)

### 5 关于二叉树存储结构的基本实现

